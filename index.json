[{"categories":null,"contents":"\r\n\rTL;DR: La configuraci√≥n de Docker necesaria para subir la API que hicimos en el posteo anterior la pueden encontrar aqu√≠: https://github.com/augustohassel/Demo-APIs üëΩ\n\rEn este segundo posteo de la serie, vamos a intentar explicar en pocas palabras (y viniendo de un ‚Äòno experto‚Äô) qu√© es Docker, para luego hacer un paso a paso que nos ayude a escribir nuestro primer Dockerfile que sirva para correr la API que hemos creado en el posteo anterior.\nLa motivaci√≥n\rEl construir y mantener una m√°quina virtual desde cero en la nube con el s√≥lo motivo de que sirva para alojar nuestra API es una tarea engorrosa y costosa‚Ä¶ Es por esto que nos vemos en la necesidad de buscar otras alternativas para lograr tener mayor control sobre los ambientes de desarrollo, intentando reducir al m√≠nimo la complejidad y los componentes que son necesarios para que funcione nuestra aplicaci√≥n. Aqu√≠ es donde entra Docker en el juego!\n\rSupuestos y definiciones\rMantenemos los mismos supuestos que en el posteo anterior y agregamos uno:\nQuien desee seguir de punta a punta esta gu√≠a, deber√° tener una cuenta en Google Cloud. Ya tendremos tiempo de ver los costos en otros posteos.\rDoy por sentado que quien lee esta gu√≠a entiende qu√© es una API REST y ha tenido alguna experiencia m√≠nima con este protocolo.\rNo soy un DevOps, as√≠ que cualquier oportunidad de mejora que vean, pueden agregarlas en los comentarios! Este punto es especialmente relevante para este posteo, ya que Docker en s√≠ tiene sus particularidades y yo no soy un experto!\rVamos a realizar todas las pruebas desde una VM que tiene Ubuntu instalado.\r\r\rManos a la obra!\r¬øQu√© es Docker? Docker es un proyecto Open Source con el cual podemos empaquetar aplicaciones en contenedores, los cuales contienen todo lo necesario para que dichas aplicaciones se puedan ejecutar. Entonces‚Ä¶ ¬øqu√© es un contenedor? Bueno, un contenedor es una unidad estandarizada de software que empaqueta todo el c√≥digo y todas sus dependencias, de manera que una aplicaci√≥n pueda correr r√°pidamente independientemente del ambiente en el que se encuentre. Es as√≠ que los contenedores a√≠slan las aplicaciones del ambiente en el que se encuentran, de manera tal que siga funcionando, a pesar de que corran en instancias de desarrollo distintas.\nHoy los contenedores de Docker se puede usar en todos lados: Linux, Windows, Data Centers, la Nube, Serverless (este ser√≠a nuestro caso!!!)\nInstalando Doker\rPrimero vamos a ‚Äòintentar‚Äô instalar Docker Desktop desde el sitio oficial: link.\nEn mi caso no cumplo con los requisitos m√≠nimos üò°, ya que tengo Windows 10 Home, as√≠ que tendr√© que dar una vuelta de tuerca a esta situaci√≥n de la siguiente manera:\nVoy a descargar e instalar Virtual Box\rLuego voy a descargarme un instalador de Ubuntu\rVoy a crear una m√°quina virtual dentro de mi m√°quina f√≠sica usando Virtual Box que contenga Ubuntu üöÄ\r\rQuienes tengan Linux o Windows 10 Pro no tendr√°n necesidad de seguir estos pasos‚Ä¶ Si quieren que haga un tutorial sobre c√≥mo hacerlo, tranquilamente lo puedo pensar para otro posteo! Por lo pronto, ahora puedo usar Ubuntu en mi m√°quina con Windows! üî•\nVamos a continuar directamente desde la m√°quina virtual con Ubuntu üòâ\nLa instalaci√≥n del engine de Docker se reduce a seguir los pasos de este tutorial: https://docs.docker.com/install/linux/docker-ce/ubuntu/\nUna vez est√© instalado, podremos correr el siguiente c√≥digo para determinar si es que ha funcionado correctamente la instalaci√≥n: sudo docker run hello-world. Si todo ha salido bien, entonces ver√°n la siguiente consola:\n\rEl poder de Docker!\rUno de los grandes beneficios de Docker es la gran comunidad que hay detr√°s creando im√°genes (simplificando, las im√°genes son como planitillas que capturan el estado de un contenedor y sirven para crear los mismos) que nos permitir√°n levantar r√°pidamente contenedores con diversas aplicaciones/configuraciones pre instaladas. Algunos link importantes a tener encuenta:\n\rListado de im√°genes p√∫blicas dentro de Docker Hub: https://hub.docker.com/search?q=\u0026amp;type=image\rImagen oficial de R en Docker Hub: https://hub.docker.com/_/r-base\rThe Rocker Prokject: https://www.rocker-project.org/\rDocumentaci√≥n sobre comandos de Docker: https://docs.docker.com/reference/\r\r\rSi se ponen a ver las im√°genes del proyecto Rocker, ver√°n que hay im√°genes que ya vienen preparadas para correr Shiny o RStudio Server directamente dockerizadas!!!\n\rVamos a probar descargando una imagen oficial que contiene R. Para hacerlo, tenemos que usar el comando docker pull con la imagen en cuesti√≥n: sudo docker pull r-base. Esta es la pantalla que ver√°n si todo va bien:\nUna vez que tengamos las im√°genes descargadas, podemos listarlas directamente con el comando sudo docker images.\nAhora vamos a una parte m√°s divertida! Podemos crear un contenedor con la imagen que acabamos de descargar y lograremos correr R a√∫n si no tenemos R instalado en nuestra m√°quina! Para hacerlo usaremos el comando sudo docker run -ti --rm r-base. En el comando estamos especificando con ‚Äò‚Äìrm‚Äô que el contenedor se tendr√° que eliminar una vez que salgamos de la consola y adem√°s estamos diciendo con ‚Äò-i‚Äô que queremos que nos quede la consola interactiva dentro del contenedor.\nPara ver los contenedores creados que est√©n activos debemos usar el comando sudo docker ps.\n\rCreando nuestra primer imagen: Dockerfile\rDocker construye im√°genes leyendo un archivo que contiene un set de instrucciones, con comandos en un orden determinado. Este archivo se llama Dockerfile. Creemos uno sencillo con el comando touch Dockerfile y agreguemos el siguiente contenido con cualquier editor de textos.\nFROM r-base:latest\rCOPY / / RUN R -e \u0026quot;1+1\u0026quot;\rCMD [\u0026quot;Rscript\u0026quot;, \u0026quot;simple.R\u0026quot;]\r\rPara seguir las buenas pr√°cticas en la construcci√≥n de un archivo Dockerfile les recomiendo leer el siguiente link.\n\rB√°sicamente lo que estamos diciendo en este archivo es que:\n\rFROM va a crear una capa de base con la imagen r-base:latest obtenida desde el repositorio de im√°genes.\rCOPY va a agregar los archivos desde la ruta donde estamos al directorio del cliente de Docker.\rRUN va a ejectura, al momento de la creaci√≥n del contenedor, una acci√≥n determinada. La que hemos elegido, no tiene mucho sentido, pero sirve para hacernos unas idea! Es m√°s √∫til para instalar librer√≠as, actualizar paquetes, etc‚Ä¶\rCMD contiene el listado de comandos y sus argumentos que se correr√°n dentro del contenedor. En este caso vamos a correr un script que adentro tiene un √∫nico comando: message(\"Hola\")\r\rObviamente hay m√°s comandos a disposici√≥n para usar dentro de un Dockerfile, pero estos nos servir√°n en un principio.\nPara construir la imagen vamos a usar el comando sudo docker build . -t 'simple' par√°ndonos en el directorio en el cual est√° guardado el Dockerfile, o colocando la direcci√≥n en vez del punto dentro del comando.\nFinalmente podemos ejecutar la imagen que acabos de crear con el comando sudo docker run -ti --rm simple para obtener un gran saludo! üéä\n\rUniendo todos los puntos\rSi llegaste hasta ac√° te estar√°s preguntando: ¬øc√≥mo hacemos para que funcione la API del posteo anterior?\nBueno! Primero hagamos un clone de repositorio en github que contiene la API: git clone https://github.com/augustohassel/Demo-APIs.git.\nLuego vamos a ubicarnos dentro de la carpeta que contiene el archivo Dockerfile y vamos a crear el contenedor con el comando que vimos antes sudo docker build . -t 'api'.\nVeremos que en la pantalla empiezan a suceder m√°s cosas que en el ejemplo anterior.\nEsto tardar√° unos minutos mientras construye la imagen con los pasos que configuramos en el Dockerfile. Mientras esto sucede veamos qu√© se est√° haciendo detr√°s:\nFROM rocker/verse:latest\rRUN apt-get update -qq \u0026amp;\u0026amp; apt-get install -y \\\rlibssl-dev \\\rlibcurl4-gnutls-dev \\\rpandoc \\\rpandoc-citeproc\rRUN R -e \u0026quot;install.packages(\u0026#39;plumber\u0026#39;)\u0026quot;\rRUN R -e \u0026quot;install.packages(\u0026#39;rmarkdown\u0026#39;)\u0026quot;\rRUN R -e \u0026quot;install.packages(\u0026#39;quantmod\u0026#39;)\u0026quot;\rRUN R -e \u0026quot;install.packages(\u0026#39;dygraphs\u0026#39;)\u0026quot;\rRUN R -e \u0026quot;install.packages(\u0026#39;xts\u0026#39;)\u0026quot;\rCOPY / /\rENTRYPOINT [\u0026quot;Rscript\u0026quot;, \u0026quot;main.R\u0026quot;]\rLo que est√° sucediendo es lo siguiente:\n\rCon FROM  estamos creando una capa con una imagen obtendida desde rocker/verse. Esta imagen es distinta a la del ejemplo anterior porque contiene librer√≠as ya preparadas para trabajar con los archivos Markdown mediente los cuales se generan los informes.\rEl primer RUN actualiza ciertos paquetes en Linux para hacer compatible ciertas librer√≠as de R, por ejemplo, para poder publicar los PDFs.\rLos RUNs subsiguientes instalan librer√≠as de R. Esto podr√≠a haber estado en un mismo archivo de configuraci√≥n y ser importado directamente con un solo RUN.\rPor √∫ltimo copiamos los arhivos con COPY.\rFinalmente indicamos el comando principal que se utilizar√° en la imagen a trav√©s de ENTRYPOINT.\r\rEl archivo main.R contiene el setup inicial de plumber, el llamado de la librer√≠a, la lectura del archivo plumber.R y la configuraci√≥n del puerto.\nlibrary(plumber)\rr \u0026lt;- plumb(\u0026quot;plumber.R\u0026quot;)\rr$run(port = as.numeric(Sys.getenv(\u0026#39;PORT\u0026#39;)), host = \u0026quot;0.0.0.0\u0026quot;)\rFinalmente, para ejectutar la imagen y crear el contenedor vamos a usar el comando sudo docker run -p 80:80 api. Este comando agrega el par√°metro ‚Äòp‚Äô para publicar el contenedor en el puerto en cuesti√≥n.\n\rEn caso de que no te haya funcionado, probablemente tengas que agregar una l√≠nea adicional en el Dockerfile antes de ENTRYPOIDNT: ENV PORT=80. Con esto te aseguraras de que la variable PORT est√° expuesta al contenedor.\n\rFinalmente, si queremos ver que est√° funcionando todo correctamente, no tenemos m√°s que ir a nuestro navegador y colocar la ruta http://127.0.0.1.\n\r\rLo logramos!\rHemos encapsulado nuestra API mediante Docker!!! Existen otros beneficios de usar Docker pero quedar√°n para otros posteos en el futuro! üî•\nEn siguiente posteo veremos como llevar finalmente nuestra API a la nube usando integraci√≥n cont√≠nua con GitHub + Google Build + Google Run! ‚òÅ üöÄ\n\r","permalink":"/blog/exponiendofuncionesderenlanube-parte_2/","tags":["API","PlumbeR","Docker","Google Cloud","Virtual Box","Ubuntu","Linux"],"title":"Exponiendo Funciones de R en la Nube: Parte 2"},{"categories":null,"contents":"\r\n\rTL;DR: El resultado final de este trabajo lo pueden encontrar en el siguiente link https://demo-api.hasselpunk.com/ üòÑ\n\rEste ser√° el primer posteo de una serie de 3, los cuales tendr√°n dos intenciones: mostrar como exponer funciones de R en la nube y dejar por escrito ciertas recomendaciones que surgieron en el proceso de desarrollo. Estoy seguro que estos consejos servir√°n a m√°s de uno (incluso a mi ‚Äòyo‚Äô del futuro!!!).\nLa serie constar√° de los siguientes posteos:\nEn el primero vamos a explicar c√≥mo usar PlumbeR para exponer funciones de R y crear un informe (tanto en HTML como en PDF!).\rEn el segundo vamos a correr nuestra API con Docker localmente. Vamos a aprender a crear el dockerfile necesario para esto.\rPor √∫ltimo veremos c√≥mo vincular GitHub con Cloud Run (de Google Cloud) usando Cloud Build para exponer nuesta API en la nube!\r\rLa motivaci√≥n\rSiempre surge la charla de c√≥mo llevar R a producci√≥n y, estoy seguro que con ciertas herramientas que surgieron en los √∫ltimos a√±os, hoy es mucho m√°s sencillo de hacerlo de lo que muchos piensan. La intenci√≥n no es desarrollar una aplicaci√≥n con Shiny, sino concentrarnos en usar el protoc√≥lo REST para que nuestros super algoritmos puedan interactuar con otras aplicaciones y lenguajes.\nPor otro lado, espec√≠ficamente en este posteo, presentaremos una manera f√°cil de desarrollar informes que se puedan actualizar diariamente sin la necesidad de tener que generarlos localmente para luego enviarlos por mail. üòâ\n\rSupuestos y definiciones\rQuien desee seguir de punta a punta esta gu√≠a, deber√° tener una cuenta en Google Cloud. Ya tendremos tiempo de ver los costos en otros posteos.\rDoy por sentado que quien lee esta gu√≠a entiende qu√© es una API REST y ha tenido alguna experiencia m√≠nima con este protocolo.\rNo soy un DevOps, as√≠ que cualquier oportunidad de mejora que vean, pueden agregarlas en los comentarios!\r\r\rManos a la obra!\r¬øQu√© es PlumbeR? PlumbeR es un paquete de R que convierte el c√≥digo que escribimos en R en una API REST. Esto lo logra gracias a ciertos comentarios que se agregan en el c√≥digo, parecidos a Roxygen. √âste √∫ltimo sirve para documentar funciones en R y quienes hayan desarrollado alguna librer√≠a en el pasado estar√°n familiarizados.\nCon las √∫ltimas versiones de RStudio, se puede crear una API con PlumbeR directamente desde el men√∫! Tan sencillo como ir a ‚ÄúFile \u0026gt; Plumber API‚Ä¶‚Äù y luego hacer click en ‚ÄúRun API‚Äù:\nYa con nuestra API demo funcionando, tenemos que entender que todo lo que estamos exponiendo, es una funci√≥n y para ellos debemos de tener presente ciertas cuestiones propias de PlumbeR:\n\rLa primer l√≠nea comentada denota el nombre de la funci√≥n. Una vez que corramos nuestra API, veremos como se genera autom√°ticamente documentaci√≥n con Swagger.\rLuego veremos una l√≠nea que denota el tipo de m√©todo, puede ser un GET, POST, PUT, etc‚Ä¶ Los princiales a tener en mente son los GET y POST, y la diferencia principal es que el primero representa m√©todos de lectura y el segundo un m√©todo de creaci√≥n. Para ver en m√°s detalle las diferencias entre los m√©todos les recomiendo este link: m√©todos HTTP\rPor √∫ltimo, encontrar los par√°metros a pasarse en la funci√≥n y estos los represetamos con @param parametro:tipo.\r\rNuestra primer funci√≥n!\r#* Devuelve la suma de dos numeros\r#* @get /sum\r#\u0026#39; @param a:numeric El primer numero\r#\u0026#39; @param b:numeric El segundo numero\rfunction(a, b) {\ras.numeric(a) + as.numeric(b)\r}\rEs tan solo una suma, pero representa la base de cualquier cosa que deseemos realizar. Aqu√≠ lo importante es recordar que no es necesario que la funci√≥n contenga todo la l√≥gica, sino que nos podemos apoyar en crear otros archivos .R y ‚Äòsourcearlos‚Äô. Para esto, tenemos que agregar source() al inicio, luego de cargar las librer√≠as. Es importante no hacerlo dentro de la funci√≥n, porque sino estaremos cargando el archivo cada vez que una persona haga un request a la funci√≥n en cuesti√≥n, algo que no ser√° para nada performante!\nQu√© saldr√° de sumar 1.3 y 2? Ve√°mosolo! https://demo-api.hasselpunk.com/sum?a=1.3\u0026amp;b=2\n\rUn informe con par√°metros y elementos din√°micos‚Ä¶\rSi todos los d√≠as nos piden que armemos un informe y el mismo se puede parametrizar, entonces esto les va a encantar: podemos armar un archivo .Rmd y luego exponerlo como una funci√≥n!\n#* Informe en HTML\r#* @get /html\r#\u0026#39; @serializer contentType list(type=\u0026quot;application/html; charset=utf-8\u0026quot;)\r#\u0026#39; @param stock:character Ticker obtenido desde Yahoo Finance\rfunction(res, stock=\u0026quot;BTC-USD\u0026quot;){\rf \u0026lt;- rmarkdown::render(\u0026quot;InformeHTML.Rmd\u0026quot;, output_format = NULL,\rparams = list(stock = stock))\rinclude_html(f, res)\r}\rAqu√≠ hay algo curioso a tener en cuenta: utilizar la funci√≥n nativa plumber::include_rmd() para renderizar el .Rmd no tendr√° mucho sentido, ya que la misma no pasa los argumentos de los par√°metros que podamos usar con Rmd‚Ä¶. pero aqu√≠ viene un gran consejo de Hadley Wickham: usar F2. Esto es: hacer click en la funci√≥n y luego en F2 para ver su c√≥digo fuente! De esta manera veremos c√≥mo est√° implementado, y a lo sumo podremos hacer los cambios necesarios seg√∫n nuestra conveniencia.\nVemos que no hay mucha diferencia entre la funci√≥n de plumber y mi funci√≥n, ambas usan include_html(), pero mi c√≥digo pasa los par√°metros dentro de render():\nfunction (file, res, format = NULL) {\rrequireRmd(\u0026quot;include_rmd\u0026quot;)\rf \u0026lt;- rmarkdown::render(file, format, quiet = TRUE)\rinclude_html(f, res)\r}\rEl resultado es un m√©todo al cual se le puede pasar el nombre del ticker (sigla que tienen los instrumentos financieros y los pueden buscar en yahoo finance) y generar√° un sitio con un informe en HTML. Veamos c√≥m ha evolucionado la cotizaci√≥n de la Bolsa de Buenos Aires o de Tesla.\nPueden probar buscar ustedes mismos otros productos financieros y armar sus informes respetando la siguiente estructura https://demo-api.hasselpunk.com/html?stock=TSLA\n\rUn informe con par√°metros en PDF\rQuiz√°s un informe con elementos din√°micos no sea la mejor opci√≥n para quienes desean imprimirlo, es por esto que tambi√©n creamos un informe pero en PDF:\n#* Informe en PDF\r#* @get /pdf\r#\u0026#39; @serializer contentType list(type=\u0026quot;application/pdf; charset=utf-8\u0026quot;)\r#\u0026#39; @param stock:character Ticker obtenido desde Yahoo Finance\rfunction(res, stock=\u0026quot;BTC-USD\u0026quot;){\rtemp \u0026lt;- tempfile(fileext = \u0026quot;.pdf\u0026quot;)\rrmarkdown::render(\u0026quot;InformePDF.Rmd\u0026quot;, output_file = temp,\routput_format = NULL,\rparams = list(stock = stock))\rreadBin(temp,\u0026#39;raw\u0026#39;, n = file.info(temp)$size)\r}\rEsta secuencia me ha llevado un tiempo pero finalmente logr√© darme cuenta que:\nHay que generar un archivo temporal con extensi√≥n .pdf\rLuego debemos guardar el pdf renderizado en el archivo temporal que hemos creado\rFinalmente leeremos este archivo temporal.\r\rCon estos pasos lograremos generar un PDF que se podr√° ver en el navegador. Veamos como fue la evoluci√≥n del Bitcoin en los √∫ltimos 6 meses: https://demo-api.hasselpunk.com/pdf?stock=BTC-USD\n\rEs muy importante usar @serializer para mostrar cual es el tipo de contenido con el que estamos trabajando.\n\r\r\rLo logramos!\rCon esto ya hemos logrado automatizar parte de nuestro trabajo: ahora los informes se generan mediante par√°metros consultando a una API y nuestros super algor√≠tmos ya est√°n expuestos tambi√©n para que otros lo usen. üî•\nPueden jugar con la API Demo que tengo en la nube y ver qu√© m√©todos est√°n disponibles en https://demo-api.hasselpunk.com/\nEn siguientes posteos seguiremos trabajando para lograr llevar todo esto a la nube! ‚òÅ\n\r","permalink":"/blog/exponiendofuncionesderenlanube-parte_1/","tags":["API","PlumbeR","Docker","Google Cloud"],"title":"Exponiendo Funciones de R en la Nube: Parte 1"},{"categories":null,"contents":"\r\n\rPara los ansiosos como yo: aqu√≠ el proyecto en GitHub desde donde pueden obtener una versi√≥n b√°sica funcional! üòÑ\n\rSiendo este es mi primero posteo, va a existir mucha referencia a desarrollos que me encantar√≠a poder explayar pero prometo intentar mantenerme concentrado y, en todo caso, si gustan, continuar√© explay√°ndome en otra ocasi√≥n.\nLa motivaci√≥n\rDesde el momento en que empec√© a armar tableros en Shiny me encontr√© con la necesidad de brindar permisos a usuarios. Esto significa que un usuario pueda, adem√°s de ver o no el contenido completo del sitio, obtener distintos tipos de acceso incluso dentro de las aplicaciones.\nSe que existen servicios como Auth0 o, si tienen suerte, la versi√≥n paga de Shiny Server Pro desde la cual pueden validar usuarios usando LDAP, Active Directory y otros. Incluso tambi√©n podr√≠an usar Shiny Proxy, el cual es open source, para que la validaci√≥n del usuario quede en manos de alguno de los tantos m√©todos existentes.\nPor curiosidad, y en ciertos momentos por necesidad, fui creando un log-in que pudiese manejar no solo el ingreso del usuario, sino tambi√©n los distintos tipos de permisos internos y vistas disponibles una vez dentro de la aplicaci√≥n.\nEste es el resultado!\r\rSupuestos y definiciones\rModules! B√°sicamente los m√≥dulos son como funciones que generan una UI de Shiny y contienen la l√≥gica del servidor asociada. Pero la verdadera m√°gia se da en que, a diferencias de las funciones, estos solucionan el problema del namespace, o sea, podemos reutilizar un mismo modulo m√∫ltiples veces dentro de una misma aplicaci√≥n sin preocuparnos por que los IDs de inputs y outpus sean distintos!\r¬øTiene sentido que una funci√≥n de log-in est√© modularizada si solo ser√° usada una sola vez dentro de la aplicaci√≥n? Podr√≠a no estar modularizada! Pero‚Ä¶ me parece un buen caso de uso para empezar a aprende sobre m√≥dulos, al mismo tiempo que es m√°s sencillo para organizar el c√≥digo y tambi√©n para compartirlo.\r\r\rManos a la obra!\rActualmente cargo m√≥dulos de dos maneras distintas dependiendo de si el m√≥dulo es espec√≠fico del tablero en que me encuntro trabajando o si es transversal a todos los tableros (en el caso del login, es el mismo m√≥dulo para todos mis tableros).\nCon la primer opci√≥n guardo todos los m√≥dulos en una carpeta llamada ‚Äúmodules‚Äù y luego hago un source desde global.R: invisible(lapply(list.files(path = \"modules\", full.names = T), source)).\nCon la segunda opci√≥n guardo los m√≥dulos en un repositorio en GitHub y luego hago un source del contenido directamente desde ah√≠! Con esto me aseguro de que solo tengo que modificar en un solo lugar y esto afecta a todos los tableros! Algo as√≠ ser√≠a:\neval(\rGET(url = \u0026quot;https://api.github.com/repos/XXXXX.R\u0026quot;, authenticate(\u0026quot;username\u0026quot;, \u0026quot;token\u0026quot;), accept(type = \u0026quot;application/vnd.github.v3.raw\u0026quot;)) %\u0026gt;%\rcontent(as = \u0026quot;text\u0026quot;) %\u0026gt;%\rparse(file = \u0026quot;\u0026quot;, n = NA)\r)\rUn modulo se compone de dos partes, muy similar a una aplicaci√≥n de Shiny, la primera es una funci√≥n que genera la interfaz y la segunda la que contiene la l√≥gica.\nModule UI\rEn nuestro caso, es bastante sencilla, porque en realidad la UI la genero tambi√©n desde la funci√≥n del server con renderUI. Esto lo hago para poder disparar el Modal!\nlogin_ui \u0026lt;- function(id) {\rns \u0026lt;- NS(id)\rtagList(\ruiOutput(ns(\u0026quot;modal_login\u0026quot;))\r)\r}\rAc√° lo importante es recordar que los inputs se envuelven con un ns(), esto crea posteriormente la magia para que no se repitan con otros IDs del mismo m√≥dulo en otro lugar de la aplicaci√≥n!\n\rModule Server\rEl modal que muestra el login contiene la informaci√≥n t√≠pica, pide un usuario y una contrase√±a, y adem√°s permite volver a resetear el password! Si quieren probar el reseteo del password en funcionamiento, pueden hacerlo pidi√©ndome un usario para la versi√≥n demo del BO Companion, donde b√°sicamente se env√≠a un correo usando alg√∫n SMTP (yo uso mailgun o mandrill seg√∫n el cliente) al correo registrado y luego se lee el hash que se genera en el link en la URL para verificar que el usaurio en efecto fue el que pidi√≥ el cambio de contrase√±a.\nLos usuarios creados para la versi√≥n demo est√°n cargados en el server.R y son:\n\r\rUsuario \u0026lt;\r\u0026gt; Contrase√±a\r\r\r\rdemo\rdemo\r\rjuan\rjuan\r\rpedro\rpedro\r\r\r\r\r\n\rAclaraci√≥n: solo por ser un caso de ejemplo estoy guardando los usuarios en un data frame en el server. En producci√≥n lo tengo todo en bases de datos en la nube en GCloud.\n\rA la funci√≥n del server function(input, output, session, usuarios_full, usuarios_validos) se le pasan dos listados, el listado completo de usuarios y los usaurios v√°lidos del tablero en cuesti√≥n. Los permisos espec√≠ficos dentro del tablero se eval√∫an en otro lugar!\nHay un observer que controla el bot√≥n de login y efect√∫a todas las validaciones correspondientes! Prueben con usuarios que no est√©n en el listado o incluso con todos los usuarios‚Ä¶ hay uno que no tiene permiso para ingresar! En cada caso se da un aviso sobre lo que est√° sucediendo.\n observeEvent(input$login, {\rshinyjs::disable(\u0026quot;login\u0026quot;)\rif (input$usuario==\u0026quot;\u0026quot;) {\rsendSweetAlert(session = session, title = \u0026quot;Mmm...\u0026quot;, text = \u0026quot;Debe colcar un usuario para acceder!\u0026quot;, type = \u0026quot;warning\u0026quot;)\r} else if (full_users() %\u0026gt;% filter(UserName == input$usuario) %\u0026gt;% nrow() == 0) {\rsendSweetAlert(session = session, title = \u0026quot;Mmm...\u0026quot;, text = \u0026quot;El usuario no existe!\u0026quot;, type = \u0026quot;warning\u0026quot;)\r} else if (valid_users() %\u0026gt;% filter(UserName == input$usuario) %\u0026gt;% nrow() == 0) {\rsendSweetAlert(session = session, title = \u0026quot;Mmm...\u0026quot;, text = \u0026quot;El usuario no posee acceso a este tablero!\u0026quot;, type = \u0026quot;warning\u0026quot;)\r} else if (valid_users() %\u0026gt;% filter(UserName == input$usuario) %\u0026gt;% pull(Password) %\u0026gt;% is.na()) {\rsendSweetAlert(session = session, title = \u0026quot;Mmm...\u0026quot;, text = HTML(\u0026quot;Debe setear una contrase\u0026amp;ntilde;a, hable con el admin!\u0026quot;), type = \u0026quot;warning\u0026quot;, html = T)\r} else {\rpass_ok \u0026lt;- identical(valid_users() %\u0026gt;% filter(UserName==input$usuario) %\u0026gt;% pull(Password), digest::digest(object = input$password, algo = \u0026quot;sha1\u0026quot;, serialize = F))\rif (pass_ok) {\rsendSweetAlert(session = session, title = \u0026quot;Bienvenido!\u0026quot;, type = \u0026quot;success\u0026quot;)\rreturn_values$user \u0026lt;- valid_users() %\u0026gt;% filter(UserName==input$usuario) %\u0026gt;% pull(UserId)\rreturn_values$person \u0026lt;- valid_users() %\u0026gt;% filter(UserName==input$usuario) %\u0026gt;% pull(PersonaId)\rreturn_values$permiso \u0026lt;- valid_users() %\u0026gt;% filter(UserName==input$usuario) %\u0026gt;% pull(Permiso)\rremoveModal()\r} else if (!pass_ok) {\rsendSweetAlert(session = session, title = \u0026quot;Error!\u0026quot;, text = HTML(\u0026quot;Contrase\u0026amp;ntilde;a Incorrecta\u0026quot;), type = \u0026quot;error\u0026quot;, html = T)\r}\r}\rshinyjs::enable(\u0026quot;login\u0026quot;)\rSi el password que tenemos registrado del usuario se condice con el password que el usuario est√° ingresando, entonces ser√° un login exitoso!\nidentical(valid_users() %\u0026gt;% filter(UserName==input$usuario) %\u0026gt;% pull(Password), digest::digest(object = input$password, algo = \"sha1\", serialize = F))\nOtra cosa importante a tener en cuenta que sucede al final de la funci√≥n es que se devuelven valores reactivos dentro de un return_values. Estos me ayudar√°n luego en la aplicaci√≥n principal a tener registradas variables globales como ser el usaurio que se est√° logueando.\n\r\rY ahora la aplicaci√≥n principal!\rEn la aplicaci√≥n principal tenemos que realizar dos tareas, primero en el UI y luego en el SERVER.\nEn el UI\rAqu√≠ agregamos una sola l√≠nea!\nlogin_ui(\"login\")\nlogin_ui tiene un solo par√°metro, y es el ID, que en este caso estamos eligiendo como id = ‚Äòlogin‚Äô. Esta es la magia que mencionamos al comienzo, si quisi√©ramos usar el mismo m√≥dulo con distintos par√°metros, solamente tendr√≠amos que preocuparnos por que este ID sea distinto!!!\n\rEn el SERVER\rAqu√≠ suceden dos cosas importantes, primero llamamos al modulo, pasando el ID que elegimos anteriormente, y le pasamos los par√°metros relevantes (hab√≠amos dicho que eran lo usuarios completos y los que ten√≠an permiso):\nlogin_result \u0026lt;- callModule(module = login,\rid = \u0026quot;login\u0026quot;, usuarios_full = usuarios_full, usuarios_validos = usuarios_validos)\rLuego se brindan los permisos en consecuencia de lo que se haya obtenido. Esto significa que voy a usar shinyjs para mostrar u ocultar partes de la aplicaci√≥n y tambi√©n el men√∫ ser√° distinto seg√∫n el permiso que tenga el usuario gracias a renderMenu:\nobserve({\rreq(!is_null(login_result$permiso))\rreq(!is_null(login_result$person))\rreq(!is_null(login_result$user))\rif (login_result$permiso %in% c(1)) { # permiso total\r# menu\routput$menu \u0026lt;- renderMenu({\rsidebarMenu(\rmenuItem(text = \u0026quot;Tab\u0026quot;, tabName = \u0026quot;first_page\u0026quot;, icon = icon(\u0026quot;skull\u0026quot;))\r)\r})\r# accesos\rshinyjs::hide(\u0026quot;login_page\u0026quot;, anim = T, animType = \u0026quot;slide\u0026quot;)\rshinyjs::show(\u0026quot;first_page_show\u0026quot;) # paginas\r} global_id_persona(login_result$person)\rglobal_id_usuario_dashboard(login_result$user)\r})\rAs√≠ es como llegamos al final y logramos tener un log-in b√°sico modularizado! Si hacen un clone del repositorio y corren la aplicaci√≥n de Shiny, van a poder interactuar y seguramente ver√°n algunas cosas extras que est√°n dando vuelta.\nEspero que haya servido este primero posteo! Todo feedback es bienvenido!\n\rBonus Track: Sigo a varios repositorios interesante sobre Shiny en Github: miralos aqu√≠\n\r\r\r","permalink":"/blog/basicloginmodularizado/","tags":["Modules","Shiny","Dashboard","BusinessIntelligence"],"title":"Basic LogIn Modularizado"},{"categories":null,"contents":"\r\rHasselPunk BO Companion es una suite de soluciones dedicada a agilizar procesos dentro de una Sociedad de Bolsa.\r\rLa instalaci√≥n b√°sica consta de los siguientes tableros:\n\r\rHome. El punto de partida: ir!\r\r\rAdministrador. Gesti√≥n y administraci√≥n de usuarios.\r\r\rRecursos Humanos. Gesti√≥n y administraci√≥n de personas.\r\r\rComercial. Acceso a informaci√≥n y an√°lisis de clientes.\r\r\r\rTablero Administrador\r\r\rDentro de este tablero se puede:\r\r\rCrear usuarios\r\r\rRecuperar contrase√±as\r\r\rGestionar permisos: cada tablero tiene 3 niveles de permisos distintos para poder habilitar la informaci√≥n √∫nicamente a los usuarios que la necesiten\r\r\rVer √∫ltimas conexiones\r\r\rVincular managers con usuarios: esto es muy √∫til cuando se quiere brindar permisos al tablero de Comercial a los productores y/o managers de cuentas, para que vean √∫nicamente sus cuentas vinculadas\r\r\r\rTablero Recursos Humanos\r\r\rAqu√≠ se podr√°:\r\r\rDar de alta personas. Estas pueden ser parte del personal o productores. En ambos casos se puede guardar informaci√≥n como estudios, domicilio, fecha de nacimiento y otros.\r\r\rSe tiene disponible un mapa con el domicilio registrado de las personas en la n√≥mina\r\r\r\rTablero Comercial\r\r\rEste es uno de los tableros centrales desde el cual se puede:\r\r\rVer r√°pidamente el AUM de los clientes que est√©n vinculados al ususario (un administrador podr√° ver todo, en tanto que un usuario que permiso por rol, solo ver√° los clientes vinculados al mismo).\r\r\rFiltrar las carteras de los clientes y descargarse la informaci√≥n necesaria para un posterior an√°lisis.\r\r\rVer resumenes de posici√≥n por cliente, desglosados seg√∫n tenencia, cuentas corrientes, posiciones en garant√≠a, etc.\r\r\rObtener resumen y estad√≠sticas sobre operaciones y comisiones generadas seg√∫n tipo de productos agrupadas por d√≠a, semana, mes o a√±o.\r\r\rObtener un an√°lisis del ranking de comisiones generadas por los comitentes, obteniendo el ticket promedio, cantidad de operaciones y porcentaje de rotaci√≥n de cartera.\r\r\r\rSi bien estas son algunas de las caracter√≠sticas de los tableros, cabe destacar que adem√°s se ofrecen soluciones m√°s avanzadas e implementaciones ad-hoc, como:\r\r\rEnv√≠o de reportes por mail, slack o telegram.\r\rProcesamiento y automatizaci√≥n de rutinas vinculadas a datos.\r\r\rArmado de algor√≠tmos de recomendaci√≥n.\r\r\rClusterizaci√≥n/segmentaci√≥n de clientes.\r\r\r\rLas principales caracter√≠sticas t√©cnicas del producto:\r\r\rCompletamente deployado en la nube en Google Cloud\r\rSe vincula con Google Analytics\r\rOpen Source! Se usa un servidor de Shiny en su versi√≥n open source, as√≠ como tambi√©n RStudio Server Open Source.\r\rPara el env√≠o de correos se utiliza Mandrill o Mailgun seg√∫n la preferencia del cliente.\r\r\r\rSi te interesa obtener un usuario demo, enviame un correo haciendo click aqu√≠ y empecemos a hablar!\r\rüòÑ\n","permalink":"/projects/hasselpunk-bo-companion/","tags":["R LanG","Shiny","tidyverse","PlumbeR","GCloud","git","GitHub","RStudio","RStudio Server","Mailgun","Mandrill"],"title":"HasselPunk BO Companion"},{"categories":null,"contents":"\r\rrRofex es una librer√≠a de R que permite conectarse al Mercado de Futuros de Matba Rofex.\r\rPara mayor informaci√≥n sobre la misma, por favor ver la documentaci√≥n completa en el GitHub de Matba Rofex.\r\rVer a la presentaci√≥n!\r","permalink":"/projects/rrofex/","tags":["R LanG","tidyverse","git","GitHub","RStudio","Restfull API","Packages","Library"],"title":"Conector rRofex"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml\n[outputs] home = [\u0026quot;HTML\u0026quot;, \u0026quot;JSON\u0026quot;] Searching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category\n... \u0026quot;contents\u0026quot;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026quot;tags\u0026quot;:{{ .Params.tags | jsonify }}{{end}}, \u0026quot;categories\u0026quot; : {{ .Params.categories | jsonify }}, ... Edit fuse.js options to Search static/js/search.js\nkeys: [ \u0026quot;title\u0026quot;, \u0026quot;contents\u0026quot;, \u0026quot;tags\u0026quot;, \u0026quot;categories\u0026quot; ] ","permalink":"/search/","tags":null,"title":"Search Results"}]