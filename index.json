[{"categories":null,"contents":"\r\n\rPara los ansiosos como yo: aqu√≠ el proyecto en GitHub desde donde pueden obtener una versi√≥n b√°sica funcional! üòÑ\n\rSiendo este es mi primero posteo, va a existir mucha referencia a desarrollos que me encantar√≠a poder explayar pero prometo intentar mantenerme concentrado y, en todo caso, si gustan, continuar√© explay√°ndome en otra ocasi√≥n.\nLa motivaci√≥n\rDesde el momento en que empec√© a armar tableros en Shiny me encontr√© con la necesidad de brindar permisos a usuarios. Esto significa que un usuario pueda, adem√°s de ver o no el contenido completo del sitio, obtener distintos tipos de acceso incluso dentro de las aplicaciones.\nSe que existen servicios como Auth0 o, si tienen suerte, la versi√≥n paga de Shiny Server Pro desde la cual pueden validar usuarios usando LDAP, Active Directory y otros. Incluso tambi√©n podr√≠an usar Shiny Proxy, el cual es open source, para que la validaci√≥n del usuario quede en manos de alguno de los tantos m√©todos existentes.\nPor curiosidad, y en ciertos momentos por necesidad, fui creando un log-in que pudiese manejar no solo el ingreso del usuario, sino tambi√©n los distintos tipos de permisos internos y vistas disponibles una vez dentro de la aplicaci√≥n.\nEste es el resultado!\r\rSupuestos y definiciones\rModules! B√°sicamente los m√≥dulos son como funciones que generan una UI de Shiny y contienen la l√≥gica del servidor asociada. Pero la verdadera m√°gia se da en que, a diferencias de las funciones, estos solucionan el problema del namespace, o sea, podemos reutilizar un mismo modulo m√∫ltiples veces dentro de una misma aplicaci√≥n sin preocuparnos por que los IDs de inputs y outpus sean distintos!\r¬øTiene sentido que una funci√≥n de log-in est√© modularizada si solo ser√° usada una sola vez dentro de la aplicaci√≥n? Podr√≠a no estar modularizada! Pero‚Ä¶ me parece un buen caso de uso para empezar a aprende sobre m√≥dulos, al mismo tiempo que es m√°s sencillo para organizar el c√≥digo y tambi√©n para compartirlo.\r\r\rManos a la obra!\rActualmente cargo m√≥dulos de dos maneras distintas dependiendo de si el m√≥dulo es espec√≠fico del tablero en que me encuntro trabajando o si es transversal a todos los tableros (en el caso del login, es el mismo m√≥dulo para todos mis tableros).\nCon la primer opci√≥n guardo todos los m√≥dulos en una carpeta llamada ‚Äúmodules‚Äù y luego hago un source desde global.R: invisible(lapply(list.files(path = \"modules\", full.names = T), source)).\nCon la segunda opci√≥n guardo los m√≥dulos en un repositorio en GitHub y luego hago un source del contenido directamente desde ah√≠! Con esto me aseguro de que solo tengo que modificar en un solo lugar y esto afecta a todos los tableros! Algo as√≠ ser√≠a:\neval(\rGET(url = \u0026quot;https://api.github.com/repos/XXXXX.R\u0026quot;, authenticate(\u0026quot;username\u0026quot;, \u0026quot;token\u0026quot;), accept(type = \u0026quot;application/vnd.github.v3.raw\u0026quot;)) %\u0026gt;%\rcontent(as = \u0026quot;text\u0026quot;) %\u0026gt;%\rparse(file = \u0026quot;\u0026quot;, n = NA)\r)\rUn modulo se compone de dos partes, muy similar a una aplicaci√≥n de Shiny, la primera es una funci√≥n que genera la interfaz y la segunda la que contiene la l√≥gica.\nModule UI\rEn nuestro caso, es bastante sencilla, porque en realidad la UI la genero tambi√©n desde la funci√≥n del server con renderUI. Esto lo hago para poder disparar el Modal!\nlogin_ui \u0026lt;- function(id) {\rns \u0026lt;- NS(id)\rtagList(\ruiOutput(ns(\u0026quot;modal_login\u0026quot;))\r)\r}\rAc√° lo importante es recordar que los inputs se envuelven con un ns(), esto crea posteriormente la magia para que no se repitan con otros IDs del mismo m√≥dulo en otro lugar de la aplicaci√≥n!\n\rModule Server\rEl modal que muestra el login contiene la informaci√≥n t√≠pica, pide un usuario y una contrase√±a, y adem√°s permite volver a resetear el password! Si quieren probar el reseteo del password en funcionamiento, pueden hacerlo pidi√©ndome un usario para la versi√≥n demo del BO Companion, donde b√°sicamente se env√≠a un correo usando alg√∫n SMTP (yo uso mailgun o mandrill seg√∫n el cliente) al correo registrado y luego se lee el hash que se genera en el link en la URL para verificar que el usaurio en efecto fue el que pidi√≥ el cambio de contrase√±a.\nLos usuarios creados para la versi√≥n demo est√°n cargados en el server.R y son:\n\r\rUsuario \u0026lt;\r\u0026gt; Contrase√±a\r\r\r\rdemo\rdemo\r\rjuan\rjuan\r\rpedro\rpedro\r\r\r\r\r\n\rAclaraci√≥n: solo por ser un caso de ejemplo estoy guardando los usuarios en un data frame en el server. En producci√≥n lo tengo todo en bases de datos en la nube en GCloud.\n\rA la funci√≥n del server function(input, output, session, usuarios_full, usuarios_validos) se le pasan dos listados, el listado completo de usuarios y los usaurios v√°lidos del tablero en cuesti√≥n. Los permisos espec√≠ficos dentro del tablero se eval√∫an en otro lugar!\nHay un observer que controla el bot√≥n de login y efect√∫a todas las validaciones correspondientes! Prueben con usuarios que no est√©n en el listado o incluso con todos los usuarios‚Ä¶ hay uno que no tiene permiso para ingresar! En cada caso se da un aviso sobre lo que est√° sucediendo.\n observeEvent(input$login, {\rshinyjs::disable(\u0026quot;login\u0026quot;)\rif (input$usuario==\u0026quot;\u0026quot;) {\rsendSweetAlert(session = session, title = \u0026quot;Mmm...\u0026quot;, text = \u0026quot;Debe colcar un usuario para acceder!\u0026quot;, type = \u0026quot;warning\u0026quot;)\r} else if (full_users() %\u0026gt;% filter(UserName == input$usuario) %\u0026gt;% nrow() == 0) {\rsendSweetAlert(session = session, title = \u0026quot;Mmm...\u0026quot;, text = \u0026quot;El usuario no existe!\u0026quot;, type = \u0026quot;warning\u0026quot;)\r} else if (valid_users() %\u0026gt;% filter(UserName == input$usuario) %\u0026gt;% nrow() == 0) {\rsendSweetAlert(session = session, title = \u0026quot;Mmm...\u0026quot;, text = \u0026quot;El usuario no posee acceso a este tablero!\u0026quot;, type = \u0026quot;warning\u0026quot;)\r} else if (valid_users() %\u0026gt;% filter(UserName == input$usuario) %\u0026gt;% pull(Password) %\u0026gt;% is.na()) {\rsendSweetAlert(session = session, title = \u0026quot;Mmm...\u0026quot;, text = HTML(\u0026quot;Debe setear una contrase\u0026amp;ntilde;a, hable con el admin!\u0026quot;), type = \u0026quot;warning\u0026quot;, html = T)\r} else {\rpass_ok \u0026lt;- identical(valid_users() %\u0026gt;% filter(UserName==input$usuario) %\u0026gt;% pull(Password), digest::digest(object = input$password, algo = \u0026quot;sha1\u0026quot;, serialize = F))\rif (pass_ok) {\rsendSweetAlert(session = session, title = \u0026quot;Bienvenido!\u0026quot;, type = \u0026quot;success\u0026quot;)\rreturn_values$user \u0026lt;- valid_users() %\u0026gt;% filter(UserName==input$usuario) %\u0026gt;% pull(UserId)\rreturn_values$person \u0026lt;- valid_users() %\u0026gt;% filter(UserName==input$usuario) %\u0026gt;% pull(PersonaId)\rreturn_values$permiso \u0026lt;- valid_users() %\u0026gt;% filter(UserName==input$usuario) %\u0026gt;% pull(Permiso)\rremoveModal()\r} else if (!pass_ok) {\rsendSweetAlert(session = session, title = \u0026quot;Error!\u0026quot;, text = HTML(\u0026quot;Contrase\u0026amp;ntilde;a Incorrecta\u0026quot;), type = \u0026quot;error\u0026quot;, html = T)\r}\r}\rshinyjs::enable(\u0026quot;login\u0026quot;)\rSi el password que tenemos registrado del usuario se condice con el password que el usuario est√° ingresando, entonces ser√° un login exitoso!\nidentical(valid_users() %\u0026gt;% filter(UserName==input$usuario) %\u0026gt;% pull(Password), digest::digest(object = input$password, algo = \"sha1\", serialize = F))\nOtra cosa importante a tener en cuenta que sucede al final de la funci√≥n es que se devuelven valores reactivos dentro de un return_values. Estos me ayudar√°n luego en la aplicaci√≥n principal a tener registradas variables globales como ser el usaurio que se est√° logueando.\n\r\rY ahora la aplicaci√≥n principal!\rEn la aplicaci√≥n principal tenemos que realizar dos tareas, primero en el UI y luego en el SERVER.\nEn el UI\rAqu√≠ agregamos una sola l√≠nea!\nlogin_ui(\"login\")\nlogin_ui tiene un solo par√°metro, y es el ID, que en este caso estamos eligiendo como id = ‚Äòlogin‚Äô. Esta es la magia que mencionamos al comienzo, si quisi√©ramos usar el mismo m√≥dulo con distintos par√°metros, solamente tendr√≠amos que preocuparnos por que este ID sea distinto!!!\n\rEn el SERVER\rAqu√≠ suceden dos cosas importantes, primero llamamos al modulo, pasando el ID que elegimos anteriormente, y le pasamos los par√°metros relevantes (hab√≠amos dicho que eran lo usuarios completos y los que ten√≠an permiso):\nlogin_result \u0026lt;- callModule(module = login,\rid = \u0026quot;login\u0026quot;, usuarios_full = usuarios_full, usuarios_validos = usuarios_validos)\rLuego se brindan los permisos en consecuencia de lo que se haya obtenido. Esto significa que voy a usar shinyjs para mostrar u ocultar partes de la aplicaci√≥n y tambi√©n el men√∫ ser√° distinto seg√∫n el permiso que tenga el usuario gracias a renderMenu:\nobserve({\rreq(!is_null(login_result$permiso))\rreq(!is_null(login_result$person))\rreq(!is_null(login_result$user))\rif (login_result$permiso %in% c(1)) { # permiso total\r# menu\routput$menu \u0026lt;- renderMenu({\rsidebarMenu(\rmenuItem(text = \u0026quot;Tab\u0026quot;, tabName = \u0026quot;first_page\u0026quot;, icon = icon(\u0026quot;skull\u0026quot;))\r)\r})\r# accesos\rshinyjs::hide(\u0026quot;login_page\u0026quot;, anim = T, animType = \u0026quot;slide\u0026quot;)\rshinyjs::show(\u0026quot;first_page_show\u0026quot;) # paginas\r} global_id_persona(login_result$person)\rglobal_id_usuario_dashboard(login_result$user)\r})\rAs√≠ es como llegamos al final y logramos tener un log-in b√°sico modularizado! Si hacen un clone del repositorio y corren la aplicaci√≥n de Shiny, van a poder interactuar y seguramente ver√°n algunas cosas extras que est√°n dando vuelta.\nEspero que haya servido este primero posteo! Todo feedback es bienvenido!\n\rBonus Track: Sigo a varios repositorios interesante sobre Shiny en Github: miralos aqu√≠\n\r\r\r","permalink":"/blog/basicloginmodularizado/","tags":["Modules","Shiny","Dashboard","BusinessIntelligence"],"title":"Basic LogIn Modularizado"},{"categories":null,"contents":"\r\rHasselPunk BO Companion es una suite de soluciones dedicada a agilizar procesos dentro de una Sociedad de Bolsa.\r\rLa instalaci√≥n b√°sica consta de los siguientes tableros:\n\r\rHome. El punto de partida: ir!\r\r\rAdministrador. Gesti√≥n y administraci√≥n de usuarios.\r\r\rRecursos Humanos. Gesti√≥n y administraci√≥n de personas.\r\r\rComercial. Acceso a informaci√≥n y an√°lisis de clientes.\r\r\r\rTablero Administrador\r\r\rDentro de este tablero se puede:\r\r\rCrear usuarios\r\r\rRecuperar contrase√±as\r\r\rGestionar permisos: cada tablero tiene 3 niveles de permisos distintos para poder habilitar la informaci√≥n √∫nicamente a los usuarios que la necesiten\r\r\rVer √∫ltimas conexiones\r\r\rVincular managers con usuarios: esto es muy √∫til cuando se quiere brindar permisos al tablero de Comercial a los productores y/o managers de cuentas, para que vean √∫nicamente sus cuentas vinculadas\r\r\r\rTablero Recursos Humanos\r\r\rAqu√≠ se podr√°:\r\r\rDar de alta personas. Estas pueden ser parte del personal o productores. En ambos casos se puede guardar informaci√≥n como estudios, domicilio, fecha de nacimiento y otros.\r\r\rSe tiene disponible un mapa con el domicilio registrado de las personas en la n√≥mina\r\r\r\rTablero Comercial\r\r\rEste es uno de los tableros centrales desde el cual se puede:\r\r\rVer r√°pidamente el AUM de los clientes que est√©n vinculados al ususario (un administrador podr√° ver todo, en tanto que un usuario que permiso por rol, solo ver√° los clientes vinculados al mismo).\r\r\rFiltrar las carteras de los clientes y descargarse la informaci√≥n necesaria para un posterior an√°lisis.\r\r\rVer resumenes de posici√≥n por cliente, desglosados seg√∫n tenencia, cuentas corrientes, posiciones en garant√≠a, etc.\r\r\rObtener resumen y estad√≠sticas sobre operaciones y comisiones generadas seg√∫n tipo de productos agrupadas por d√≠a, semana, mes o a√±o.\r\r\rObtener un an√°lisis del ranking de comisiones generadas por los comitentes, obteniendo el ticket promedio, cantidad de operaciones y porcentaje de rotaci√≥n de cartera.\r\r\r\rSi bien estas son algunas de las caracter√≠sticas de los tableros, cabe destacar que adem√°s se ofrecen soluciones m√°s avanzadas e implementaciones ad-hoc, como:\r\r\rEnv√≠o de reportes por mail, slack o telegram.\r\rProcesamiento y automatizaci√≥n de rutinas vinculadas a datos.\r\r\rArmado de algor√≠tmos de recomendaci√≥n.\r\r\rClusterizaci√≥n/segmentaci√≥n de clientes.\r\r\r\rLas principales caracter√≠sticas t√©cnicas del producto:\r\r\rCompletamente deployado en la nube en Google Cloud\r\rSe vincula con Google Analytics\r\rOpen Source! Se usa un servidor de Shiny en su versi√≥n open source, as√≠ como tambi√©n RStudio Server Open Source.\r\rPara el env√≠o de correos se utiliza Mandrill o Mailgun seg√∫n la preferencia del cliente.\r\r\r\rSi te interesa obtener un usuario demo, enviame un correo haciendo click aqu√≠ y empecemos a hablar!\r\rüòÑ\n","permalink":"/projects/hasselpunk-bo-companion/","tags":["R LanG","Shiny","tidyverse","PlumbeR","GCloud","git","GitHub","RStudio","RStudio Server","Mailgun","Mandrill"],"title":"HasselPunk BO Companion"},{"categories":null,"contents":"\r\rrRofex es una librer√≠a de R que permite conectarse al Mercado de Futuros de Matba Rofex.\r\rPara mayor informaci√≥n sobre la misma, por favor ver la documentaci√≥n completa en el GitHub de Matba Rofex.\r\rVer a la presentaci√≥n!\r","permalink":"/projects/rrofex/","tags":["R LanG","tidyverse","git","GitHub","RStudio","Restfull API","Packages","Library"],"title":"Conector rRofex"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml\n[outputs] home = [\u0026quot;HTML\u0026quot;, \u0026quot;JSON\u0026quot;] Searching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category\n... \u0026quot;contents\u0026quot;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026quot;tags\u0026quot;:{{ .Params.tags | jsonify }}{{end}}, \u0026quot;categories\u0026quot; : {{ .Params.categories | jsonify }}, ... Edit fuse.js options to Search static/js/search.js\nkeys: [ \u0026quot;title\u0026quot;, \u0026quot;contents\u0026quot;, \u0026quot;tags\u0026quot;, \u0026quot;categories\u0026quot; ] ","permalink":"/search/","tags":null,"title":"Search Results"}]