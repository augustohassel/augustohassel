[{"categories":null,"contents":"\r\rPara los ansiosos como yo: aquí el proyecto en GitHub desde donde pueden obtener una versión básica funcional!\n\rSiendo este es mi primero posteo, va a existir mucha referencia a desarrollos que me encantaría poder explayar pero prometo intentar mantenerme concentrado y, en todo caso, si gustan, continuaré explayándome en otra ocasión.\nLa motivación\rDesde el momento en que empecé a armar tableros en Shiny me encontré con la necesidad de brindar permisos a usuarios. Esto significa que un usuario pueda, además de ver o no el contenido completo del sitio, obtener distintos tipos de acceso incluso dentro de las aplicaciones.\nSe que existen servicios como Auth0 o, si tienen suerte, la versión paga de Shiny Server Pro desde la cual pueden validar usuarios usando LDAP, Active Directory y otros. Incluso también podrían usar Shiny Proxy, el cual es open source, para que la validación del usuario quede en manos de alguno de los tantos métodos existentes.\nPor curiosidad, y en ciertos momentos por necesidad, fui creando un log-in que pudiese manejar no solo el ingreso del usuario, sino también los distintos tipos de permisos intenros y vistas disponibles una vez dentro de la aplicación.\n\rSupuestos y definiciones\rModules! Básicamente los módulos son como funciones que generan una UI de Shiny y contienen la lógica del servidor asociada. Pero la verdadera mágia se da en que, a diferencias de las funciones, estos solucionan el problema del namespace, o sea, podemos reutilizar un mismo modulo múltiples veces dentro de una misma aplicación sin preocuparnos por que los IDs de inputs y outpus sean distintos!\r¿Tiene sentido que una función de log-in esté modularizada si solo será usada una sola vez dentro de la aplicación? Podría no estar modularizada! Pero… me parece un buen caso de uso para empezar a aprende sobre módulos, al mismo tiempo que es más sencillo para organizar el código y también para compartirlo.\r\r\rManos a la obra!\rActualmente cargo módulos de dos maneras distintas dependiendo de si el módulo es específico del tablero en que me encuntro trabajando o si es transversal a todos los tableros (en el caso del login, es el mismo módulo para todos mis tableros).\nCon la primer opción guardo todos los módulos en una carpeta llamada “modules” y luego hago un source desde global.R: invisible(lapply(list.files(path = \"modules\", full.names = T), source)).\nCon la segunda opción guardo los módulos en un repositorio en GitHub y luego hago un source del contenido directamente desde ahí! Con esto me aseguro de que solo tengo que modificar en un solo lugar y esto afecta a todos los tableros! Algo así sería:\neval(\rGET(url = \u0026quot;https://api.github.com/repos/XXXXX.R\u0026quot;, authenticate(\u0026quot;username\u0026quot;, \u0026quot;token\u0026quot;), accept(type = \u0026quot;application/vnd.github.v3.raw\u0026quot;)) %\u0026gt;%\rcontent(as = \u0026quot;text\u0026quot;) %\u0026gt;%\rparse(file = \u0026quot;\u0026quot;, n = NA)\r)\rUn modulo se compone de dos partes, muy similar a una aplicación de Shiny, la primera es una función que genera la interfaz y la segunda la que contiene la lógica.\nModule UI\rEn nuestro caso, es bastante sencilla, porque en realidad la UI la genero también desde la función del server con renderUI. Esto lo hago para poder disparar el Modal!\nlogin_ui \u0026lt;- function(id) {\rns \u0026lt;- NS(id)\rtagList(\ruiOutput(ns(\u0026quot;modal_login\u0026quot;))\r)\r}\rAcá lo importante es recordar que los inputs se envuelven con un ns(), esto crea posteriormente la magia para que no se repitan con otros IDs del mismo módulo en otro lugar de la aplicación!\n\rModule Server\rEl modal que muestra el login contiene la información típica, pide un usuario y una contraseña, y además permite volver a resetear el password! Si quieren probar el reseteo del password en funcionamiento, pueden hacerlo pidiéndome un usario para la versión demo del BO Companion, donde básicamente se envía un correo usando algún SMTP (yo uso mailgun o mandrill según el cliente) al correo registrado y luego se lee el hash que se genera en el link en la URL para verificar que el usaurio en efecto fue el que pidió el cambio de contraseña.\nLos usuarios creados para la versión demo están cargados en el server.R y son:\n\r\rUsuario \u0026lt;\r\u0026gt; Contraseña\r\r\r\rdemo\rdemo\r\rjuan\rjuan\r\rpedro\rpedro\r\r\r\r\r\r\r\n\rAclaración: solo por ser un caso de ejemplo estoy guardando los usuarios en un data frame en el server. En producción lo tengo todo en bases de datos en la nube en GCloud.\n\rA la función del server function(input, output, session, usuarios_full, usuarios_validos) se le pasan dos listados, el listado completo de usuarios y los usaurios válidos del tablero en cuestión. Los permisos específicos dentro del tablero se evalúan en otro lugar!\nHay un observer que controla el botón de login y efectúa todas las validaciones correspondientes! Prueben con usuarios que no estén en el listado o incluso con todos los usuarios… hay uno que no tiene permiso para ingresar! En cada caso se da un aviso sobre lo que está sucediendo.\n observeEvent(input$login, {\rshinyjs::disable(\u0026quot;login\u0026quot;)\rif (input$usuario==\u0026quot;\u0026quot;) {\rsendSweetAlert(session = session, title = \u0026quot;Mmm...\u0026quot;, text = \u0026quot;Debe colcar un usuario para acceder!\u0026quot;, type = \u0026quot;warning\u0026quot;)\r} else if (full_users() %\u0026gt;% filter(UserName == input$usuario) %\u0026gt;% nrow() == 0) {\rsendSweetAlert(session = session, title = \u0026quot;Mmm...\u0026quot;, text = \u0026quot;El usuario no existe!\u0026quot;, type = \u0026quot;warning\u0026quot;)\r} else if (valid_users() %\u0026gt;% filter(UserName == input$usuario) %\u0026gt;% nrow() == 0) {\rsendSweetAlert(session = session, title = \u0026quot;Mmm...\u0026quot;, text = \u0026quot;El usuario no posee acceso a este tablero!\u0026quot;, type = \u0026quot;warning\u0026quot;)\r} else if (valid_users() %\u0026gt;% filter(UserName == input$usuario) %\u0026gt;% pull(Password) %\u0026gt;% is.na()) {\rsendSweetAlert(session = session, title = \u0026quot;Mmm...\u0026quot;, text = HTML(\u0026quot;Debe setear una contrase\u0026amp;ntilde;a, hable con el admin!\u0026quot;), type = \u0026quot;warning\u0026quot;, html = T)\r} else {\rpass_ok \u0026lt;- identical(valid_users() %\u0026gt;% filter(UserName==input$usuario) %\u0026gt;% pull(Password), digest::digest(object = input$password, algo = \u0026quot;sha1\u0026quot;, serialize = F))\rif (pass_ok) {\rsendSweetAlert(session = session, title = \u0026quot;Bienvenido!\u0026quot;, type = \u0026quot;success\u0026quot;)\rreturn_values$user \u0026lt;- valid_users() %\u0026gt;% filter(UserName==input$usuario) %\u0026gt;% pull(UserId)\rreturn_values$person \u0026lt;- valid_users() %\u0026gt;% filter(UserName==input$usuario) %\u0026gt;% pull(PersonaId)\rreturn_values$permiso \u0026lt;- valid_users() %\u0026gt;% filter(UserName==input$usuario) %\u0026gt;% pull(Permiso)\rremoveModal()\r} else if (!pass_ok) {\rsendSweetAlert(session = session, title = \u0026quot;Error!\u0026quot;, text = HTML(\u0026quot;Contrase\u0026amp;ntilde;a Incorrecta\u0026quot;), type = \u0026quot;error\u0026quot;, html = T)\r}\r}\rshinyjs::enable(\u0026quot;login\u0026quot;)\rSi el password que tenemos registrado del usuario se condice con el password que el usuario está ingresando, entonces será un login exitoso!\nidentical(valid_users() %\u0026gt;% filter(UserName==input$usuario) %\u0026gt;% pull(Password), digest::digest(object = input$password, algo = \"sha1\", serialize = F))\nOtra cosa importante a tener en cuenta que sucede al final de la función es que se devuelven valores reactivos dentro de un return_values. Estos me ayudarán luego en la aplicación principal a tener registradas variables globales como ser el usaurio que se está logueando.\n\r\rY ahora la aplicación principal!\rEn la aplicación principal tenemos que realizar dos tareas, primero en el UI y luego en el SERVER.\nEn el UI\rAquí agregamos una sola línea!\nlogin_ui(\"login\")\nlogin_ui tiene un solo parámetro, y es el ID, que en este caso estamos eligiendo como id = ‘login’. Esta es la magia que mencionamos al comienzo, si quisiéramos usar el mismo módulo con distintos parámetros, solamente tendríamos que preocuparnos por que este ID sea distinto!!!\n\rEn el SERVER\rAquí suceden dos cosas importantes, primero llamamos al modulo, pasando el ID que elegimos anteriormente, y le pasamos los parámetros relevantes (habíamos dicho que eran lo usuarios completos y los que tenían permiso):\nlogin_result \u0026lt;- callModule(module = login,\rid = \u0026quot;login\u0026quot;, usuarios_full = usuarios_full, usuarios_validos = usuarios_validos)\rLuego se brindan los permisos en consecuencia de lo que se haya obtenido. Esto significa que voy a usar shinyjs para mostrar u ocultar partes de la aplicación y también el menú será distinto según el permiso que tenga el usuario gracias a renderMenu:\nobserve({\rreq(!is_null(login_result$permiso))\rreq(!is_null(login_result$person))\rreq(!is_null(login_result$user))\rif (login_result$permiso %in% c(1)) { # permiso total\r# menu\routput$menu \u0026lt;- renderMenu({\rsidebarMenu(\rmenuItem(text = \u0026quot;Tab\u0026quot;, tabName = \u0026quot;first_page\u0026quot;, icon = icon(\u0026quot;skull\u0026quot;))\r)\r})\r# accesos\rshinyjs::hide(\u0026quot;login_page\u0026quot;, anim = T, animType = \u0026quot;slide\u0026quot;)\rshinyjs::show(\u0026quot;first_page_show\u0026quot;) # paginas\r} global_id_persona(login_result$person)\rglobal_id_usuario_dashboard(login_result$user)\r})\rAsí es como llegamos al final y logramos tener un log-in básico modularizado! Si hacen un clone del repositorio y corren la aplicación de Shiny, van a poder interactuar y seguramente verán algunas cosas extras que están dando vuelta.\nEspero que haya servido este primero posteo! Todo feedback es bienvenido!\n\rBonus Track: Sigo a varios repositorios interesante sobre Shiny en Github: https://github.com/augustohassel?tab=stars\n\r\r\r","permalink":"/blog/basicloginmodularizado/","tags":["Modules","Shiny"],"title":"Basic LogIn Modularizado"},{"categories":null,"contents":"HasselPunk BO Companion es una suite de soluciones dedicada a agilizar procesos dentro de una Sociedad de Bolsa.\nLa instalación básica consta de los siguientes tableros:\n Home. El punto de partida: ir! Administrador. Gestión y administración de usuarios. Recursos Humanos. Gestión y administración de personas. Comercial. Acceso a información y análisis de clientes.  Tablero Administrador Dentro de este tablero se puede:  Crear usuarios Recuperar contraseñas Gestionar permisos: cada tablero tiene 3 niveles de permisos distintos para poder habilitar la información únicamente a los usuarios que la necesiten Ver últimas conexiones Vincular managers con usuarios: esto es muy útil cuando se quiere brindar permisos al tablero de Comercial a los productores y/o managers de cuentas, para que vean únicamente sus cuentas vinculadas  Tablero Recursos Humanos Aquí se podrá:  Dar de alta personas. Estas pueden ser parte del personal o productores. En ambos casos se puede guardar información como estudios, domicilio, fecha de nacimiento y otros. Se tiene disponible un mapa con el domicilio registrado de las personas en la nómina  Tablero Comercial Este es uno de los tableros centrales desde el cual se puede:  Ver rápidamente el AUM de los clientes que estén vinculados al ususario (un administrador podrá ver todo, en tanto que un usuario que permiso por rol, solo verá los clientes vinculados al mismo). Filtrar las carteras de los clientes y descargarse la información necesaria para un posterior análisis. Ver resumenes de posición por cliente, desglosados según tenencia, cuentas corrientes, posiciones en garantía, etc. Obtener resumen y estadísticas sobre operaciones y comisiones generadas según tipo de productos agrupadas por día, semana, mes o año. Obtener un análisis del ranking de comisiones generadas por los comitentes, obteniendo el ticket promedio, cantidad de operaciones y porcentaje de rotación de cartera.  Si bien estas son algunas de las características de los tableros, cabe destacar que además se ofrecen soluciones más avanzadas e implementaciones ad-hoc, como:  Envío de reportes por mail, slack o telegram. Procesamiento y automatización de rutinas vinculadas a datos. Armado de algorítmos de recomendación. Clusterización/segmentación de clientes.  Las principales características técnicas del producto:  Completamente deployado en la nube en Google Cloud Se vincula con Google Analytics Open Source! Se usa un servidor de Shiny en su versión open source, así como también RStudio Server Open Source. Para el envío de correos se utiliza Mandrill o Mailgun según la preferencia del cliente. \nSi te interesa obtener un usuario demo, enviame un correo haciendo click aquí y empecemos a hablar!\n","permalink":"/projects/creations/hasselpunk-bo-companion/","tags":["R Lang","Shiny","tidyverse","PlumbeR","GCloud","git","GitHub","RStudio","RStudio Server","Mailgun","Mandrill"],"title":"HasselPunk BO Companion"},{"categories":null,"contents":"rRofex es una librería de R que permite conectarse al Mercado de Futuros de Matba Rofex.\nPara mayor información sobre la misma, por favor ver la documentación completa en el GitHub de Matba Rofex.\nIr a la presentación\n","permalink":"/projects/creations/rrofex/","tags":["R Lang","tidyverse","git","GitHub","RStudio","Restfull API"],"title":"Conector rRofex"},{"categories":null,"contents":" This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml\n[outputs] home = [\u0026quot;HTML\u0026quot;, \u0026quot;JSON\u0026quot;]  Searching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category\n... \u0026quot;contents\u0026quot;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026quot;tags\u0026quot;:{{ .Params.tags | jsonify }}{{end}}, \u0026quot;categories\u0026quot; : {{ .Params.categories | jsonify }}, ...  Edit fuse.js options to Search static/js/search.js\nkeys: [ \u0026quot;title\u0026quot;, \u0026quot;contents\u0026quot;, \u0026quot;tags\u0026quot;, \u0026quot;categories\u0026quot; ]  ","permalink":"/search/","tags":null,"title":"Search Results"}]